############################################################
# INTESTAZIONE DA DECIDERE

# Created by:	Elena Ruggiano, Federico Oliva
# Date: 	23-03-2018	

# This library has been developed to organize 
############################################################


# IMPORTS
# All the libraries can be installed by pip except for:
#	ctools: download and install from
#	gammalib: download and install from
#	cscripts: download and install from 

import os 
import ctools
import cscripts
import gammalib
import sys
import argparse
import string
import random
import numpy
import pathlib
import shutil
import math
from astropy.io import fits
from GammaPipeCommon.SkyImage import SkyImage
from astropy.wcs import WCS
import matplotlib.pyplot as plt
import scipy.ndimage as ndimage
import time
from tqdm import tqdm

# SELF BUILT LIBRARIES
import map_creator
import data_analysis
import order

############################################################
# This function organizes all the files generated by recall_inaf.py or recall.py dividing the maps 
# depending on the noise level. 
# The library is organized as follows:
#		1)	function map_foldering() :	this function creates all the filesystem organization and then
#									for each map created by recall.py it computes the SNR sigma
#									and it moves the files in the appropriate folder	
#		2)	function find_counts():	this function extracts from the ctselect.log and the ctobs.log 
#									the counters that will be used to compute the SNR of a source
#		3)	function write_log():		this function writes a logfile specifically suited on the set of 
#									maps within a SNR cluster.
#		4)	function name_correction():This function changes the names of the files and of their path.
############################################################			 	


############################################################
# This function is divided into 2 main parts:
# 1) the first part is devoted to the filesystem organization. As in the following part all the maps will be 
#	stored depending on their SNR and number of sources, here 4 directories are created:
#		a) sgma3 = directory for all maps where sources have SNR <= 3
#		b) sgma4 = directory for all maps where sources have 3< SNR <= 4
#		c) sgma4 = directory for all maps where sources have SNR > 4
#		d) background = directory with all the maps with no sources
#	then all the following operations will be performed on a temporary directory that is maps_temp
# 2) the second part is devoted to the computation of the SNR of all the maps with at least a source.
#	 this is done by extracting some counters stored in specific logfiles obtained by menas of "ctselect"
#	 and "ctbin" methods which are part of the ctools package. After that all the maps are stored in 
#	their specific folder. For additional info on the SNR refer to the "Report.pdf" file.
############################################################
def map_foldering():

	# call the function usage() in order to print the inline help if needed
	usage()

	# coordinates init
	coordinates = numpy.zeros(2,dtype=int)	
	
	# get input from user
	xml_dir = sys.argv[1]
	events_dir = sys.argv[2]
	coordinates[0] = float(sys.argv[3])
	coordinates[1] = float(sys.argv[4])
	
	# logfile management
	dest_logfile = 'sigma_recap.log'
	dest = open(dest_logfile, 'w')

	# filesystem management
	if os.path.isdir('maps_temp'):
		shutil.rmtree('maps_temp')	
	os.system('cp -r ' + xml_dir + ' maps_temp')
	
	if os.path.isdir('zipdir'):
		shutil.rmtree('zipdir')	
	
	os.system('mkdir zipdir')
	os.system('mkdir zipdir/sigma3')
	os.system('mkdir zipdir/sigma4')
	os.system('mkdir zipdir/sigma5')
	os.system('mkdir zipdir/background')
	os.system('mkdir zipdir/total')

	os.system('mv maps_temp/Map.log zipdir/')

	# order the content of maps_temp 
	name_array, n_files = order.directory_order_xml('maps_temp')

	# extract true coordinates from Map.log (calls data_analysis.py)
	n_sources_array, true_array = data_analysis.true_coordinates('zipdir/Map.log', n_files)
	
	# counter init
	coord_pos = 0

	# SNR computation and map storage
	for i in tqdm(range(n_files)):
		# file names creation
		event_name = 'Events_' + str(i+1) + '.fits'
		ctobs_log_name = 'ctobssim_' + str(i+1) + '.log'
		cube_name = 'Map_' + str(i+1) + '.fits'

		# file management
		os.system('cp ' + events_dir + '/'  + event_name + ' ./events.fits')
		os.system('cp ' + events_dir + '/'  + ctobs_log_name + ' ./ctobssim.log')
				
		# log creation
		if (n_sources_array[i] != 0):
			os.system( 'ctselect inobs=events.fits ra=' + str(true_array[2*coord_pos + 1]) + ' dec=' \
+ str(true_array[2*coord_pos]) +  ' rad=0.2 tmin=2020-01-01T00:00:00 tmax=2020-01-01T00:15:00 \
emin=0.1 emax=100.0 outobs=selected_events.fits')	
			coord_pos = coord_pos + 1
			S, B = find_counts('ctobssim.log', 'ctselect.log')
			sigma = float(S)/math.sqrt(float(B))
			dest.write('SIGMA ' + name_array[i] + ' :\t' + str(sigma) + '\n')
		else:
			os.system( 'ctselect inobs=events.fits ra=' + str(coordinates[0]) + ' dec=' + \
str(coordinates[1]) +  ' rad=0.2 tmin=2020-01-01T00:00:00 tmax=2020-01-01T00:15:00 emin=0.1 \
emax=100.0 outobs=selected_events.fits')

		os.system( 'ctbin inobs=events.fits coordsys=CEL proj=CAR xref=' + str(coordinates[0]) + \
' yref=' + str(coordinates[1])  + ' binsz=0.02 nxpix=200 nypix=200 ebinalg=LOG emin=0.1 emax=100 \
enumbins=1 outcube=cube.fits' )

		# file name creation
		select_event_name = 'Selected_events_' + str(i+1) + '.fits'
		sky_name = 'Sky_' + str(i+1) + '.png'
		dir_name = 'Map_' + str(i+1)
		ctsel_log_name = 'ctselect_' + str(i+1) + '.log'

		# total folder construction
		os.system('cp cube.fits zipdir/total/' + cube_name)
		
		# partial folder construction
		if (n_sources_array[i] != 0):
			if (sigma < 4):
				os.system('cp cube.fits zipdir/sigma3/' + cube_name)
			elif (sigma < 5):
				os.system('cp cube.fits zipdir/sigma4/' + cube_name)
			else:
				os.system('cp cube.fits zipdir/sigma5/' + cube_name)
		else:
			os.system('cp cube.fits zipdir/background/' + cube_name)

	# partial logfile creation
	print('creating sigma3 log...')
	write_log('zipdir/sigma3', n_files ,'sigmalog', 'zipdir/Map.log' )
	name_correction('zipdir/sigma3', 'sigmalog')
	
	os.system('mv sigmalog zipdir/Map_sigma3.log')

	print('creating sigma4 log...')
	write_log('zipdir/sigma4', n_files ,'sigmalog', 'zipdir/Map.log' )
	name_correction('zipdir/sigma4', 'sigmalog')
	
	os.system('mv sigmalog zipdir/Map_sigma4.log')

	print('creating sigma5 log...')
	write_log('zipdir/sigma5', n_files ,'sigmalog', 'zipdir/Map.log' )
	name_correction('zipdir/sigma5', 'sigmalog')
	
	os.system('mv sigmalog zipdir/Map_sigma5.log')

	print('creating background log...')
	write_log('zipdir/background', n_files ,'sigmalog', 'zipdir/Map.log' )
	name_correction('zipdir/background', 'sigmalog')

	os.system('mv sigmalog zipdir/Background_sigma.log')

	# temporary files deletion
	if os.path.isdir('maps_temp'):
		shutil.rmtree('maps_temp')

	dest.close()

	if os.path.isfile('dataset.zip'):
		os.system('rm dataset.zip')
		
	# creation of a .zip file
	print('zipping files...')
	os.system('zip -r dataset.zip zipdir &> trash.log')
	os.system('rm trash.log')

	return 0


############################################################
# This function is devoted to extract from "ctobs.log" and "ctselect.log" the events counter that will
# be used to compute the SNR of the map. The returned values are S and B. The SNR is defined 
# depending on these values. 
############################################################
def find_counts(logfile_ctobs, logfile_ctsel):

	# open and split the ctobs logfile. Then look for the number of maps
	line_count = 0
	temp_count = 0
	with open(logfile_ctobs, 'r') as f:
		for line in f:
			line_count = line_count + 1
	f.close()
	with open(logfile_ctobs, 'r') as f:
		for line in f:
			temp_count = temp_count+1
			if (temp_count == line_count -11):
				line_array = line.split()
				MC_sources = line_array[5]
	f.close()

	# open and split the ctobs logfile. Then look for the number of maps
	temp_count = 0
	line_count = 0
	with open(logfile_ctsel, 'r') as f:
		for line in f:
			line_count = line_count + 1
	f.close()
	with open(logfile_ctsel, 'r') as f:
		for line in f:
			temp_count = temp_count+1
			if (temp_count == line_count -8):
				line_array = line.split()
				obs_events = line_array[6]
	f.close()
	return MC_sources, obs_events

############################################################
# This function writes a logfile specifically suited on the set of maps within a SNR cluster. In doing so it
# will be possible to analyze all the maps with a certain SNR by calling properly data_analysis.py
############################################################
def write_log(fits_dir, n_maps_total, logfile, maplog):

	# list directory content and get number of files
	name_array = os.listdir(fits_dir)
	n_maps = len(name_array)

	# logfile creation
	log = open(logfile, 'w')
	log.write('GENERATED COORDINATES AND INTENSITIES\n\n')
	log.write('TOTAL NUMBER OF MAPS:\t' + str(n_maps) + '\n\n')
	log.write('FILE\t\t' +  'BACKGROUND\t' + 'N_SOURCES\t\t' + 'RA\t\t' + 'DEC\t\t' + \
			'INTENSITY\n\n')

	# coordinates writing procedure
	found = False
	for i in range(0,n_maps):
		name = 'Map_' + str(i+1) + '.xml'
		curr_name = name_array[i]
		curr_name = curr_name.replace('.fits', '.xml')
		with open(maplog, 'r') as f:
			for line in f:
				split_line = line.split()
				if ( split_line != [] ):
					if ( (str(split_line[0]) == curr_name)  and (found == False) ):
						log.write(line)
						found = True
						n_temp=int(split_line[2])
					elif ((found == True) and (n_temp>0)):	
						log.write('\t' + line + '\n')
						found = False
					elif ((found == True) and (n_temp == 0)):
						found = False

############################################################
# This function changes the names of the files and of their path. This is used because the logfiles are
# created in a temporary folder and not with respect to the real path of the organized filesystem.
############################################################
def name_correction(fitsdir, maplog):
	
	nmaps = (len(os.listdir(fitsdir)))

	# first correction
	i = 1
	with open(maplog, 'r') as f:
		filedata = f.read()
	with open(maplog, 'r') as f:
		for line in f:
			split_line = line.split()
			if ( (split_line != []) and (split_line[0][0] == 'M') ):
				curr_name = split_line[0]
				filename = curr_name.replace( 'xml', 'fits')
				filename = fitsdir + '/' + filename
				tempname = fitsdir + '/Temp_' + str(i)
				tempname_log = 'tmp_' + str(i) + '.xml'
				os.rename(filename, tempname)
				filedata = filedata.replace(curr_name, tempname_log)
				i = i+1
	
	with open(maplog, 'w') as f:
		f.write(filedata)
	
	i = 1
	with open(maplog, 'r') as f:
		filedata = f.read()

	# second correction
	with open(maplog, 'r') as f:
		for line in f:
			split_line = line.split()
			if ( (split_line != []) and (split_line[0][0] == 't') ):
				curr_name = split_line[0]
				mapname = 'Map_' + str(i) + '.xml'
				filedata = filedata.replace(curr_name, mapname)
				i = i+1
	
	with open(maplog, 'w') as f:
		f.write(filedata)

	# final rename procedure
	for i in range(nmaps):
		mapname = fitsdir +  '/Map_' + str(i+1) + '.fits'
		tempname = fitsdir + '/Temp_' + str(i+1)
		os.rename(tempname, mapname)


############################################################
# function devoted to generate the parameters of the main program and the related --help function. 
# All the parameters needed by the main function are described below
############################################################
def usage():
	parser = argparse.ArgumentParser(description='program devoted to otganize already present \
								      maps in the filesystem depending on their SNR')
	parser.add_argument('Generated .xml folder', metavar = 'xml_dir', type=str, help='Directory \
						where maps .xml files are saved' )
	parser.add_argument('Generated .events folder', metavar = 'events_dir', type=str, help='Directory \
						where generated .events files are saved' )
	parser.add_argument('RA source coordinate', metavar = 'RA', type=str, help='RA source \
						coordinate - celestial coordinates' )
	parser.add_argument('DEC source coordinate', metavar = 'DEC', type=str, help='RA source \
						coordinate - celestial coordinates' )
	args = parser.parse_args()

############################################################
 # if the file is run from terminal exeute function map_foldering() by default
############################################################
if __name__ == "__main__":
    map_foldering()


